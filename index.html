
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Backend Pinger Pro</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #0f0f23;
      color: #e4e4e7;
      min-height: 100vh;
    }

    .header {
      background: linear-gradient(135deg, #1e40af 0%, #7c3aed 100%);
      padding: 20px 40px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    .header h1 {
      font-size: 28px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header p {
      color: rgba(255,255,255,0.8);
      margin-top: 5px;
      font-size: 14px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 30px 40px;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      gap: 20px;
      margin-bottom: 30px;
    }

    .card {
      background: #1c1c2e;
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      border: 1px solid #2d2d44;
    }

    .card-title {
      font-size: 13px;
      color: #a1a1aa;
      margin-bottom: 8px;
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    .card-value {
      font-size: 32px;
      font-weight: 700;
      color: #fff;
      margin-bottom: 4px;
    }

    .card-subtitle {
      font-size: 12px;
      color: #71717a;
    }

    .card-success .card-value { color: #22c55e; }
    .card-error .card-value { color: #ef4444; }
    .card-warning .card-value { color: #f59e0b; }
    .card-info .card-value { color: #3b82f6; }

    .control-panel {
      background: #1c1c2e;
      border-radius: 16px;
      padding: 28px;
      margin-bottom: 30px;
      border: 1px solid #2d2d44;
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 24px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
    }

    label {
      font-size: 13px;
      color: #a1a1aa;
      margin-bottom: 8px;
      font-weight: 600;
    }

    input {
      background: #27273a;
      border: 2px solid #3f3f51;
      border-radius: 10px;
      padding: 12px 16px;
      color: #fff;
      font-size: 15px;
      transition: all 0.3s;
    }

    input:focus {
      outline: none;
      border-color: #6366f1;
      background: #2d2d44;
    }

    .button-group {
      display: flex;
      gap: 12px;
    }

    button {
      flex: 1;
      padding: 14px 24px;
      border: none;
      border-radius: 10px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
    }

    .btn-danger {
      background: #dc2626;
      color: white;
    }

    .btn-danger:hover:not(:disabled) {
      background: #b91c1c;
    }

    .btn-secondary {
      background: #3f3f51;
      color: #e4e4e7;
    }

    .btn-secondary:hover {
      background: #4b4b5f;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .status-banner {
      background: linear-gradient(135deg, #27273a 0%, #1c1c2e 100%);
      border-radius: 12px;
      padding: 16px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      border: 2px solid #3f3f51;
    }

    .status-banner.active {
      border-color: #22c55e;
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(34, 197, 94, 0.05) 100%);
    }

    .status-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #71717a;
    }

    .status-banner.active .status-dot {
      background: #22c55e;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.1); }
    }

    .two-column {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 20px;
    }

    .log-panel {
      background: #1c1c2e;
      border-radius: 16px;
      padding: 24px;
      border: 1px solid #2d2d44;
    }

    .log-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .log-header h3 {
      font-size: 18px;
      font-weight: 600;
    }

    .log-actions {
      display: flex;
      gap: 8px;
    }

    .btn-icon {
      background: #27273a;
      border: 1px solid #3f3f51;
      color: #a1a1aa;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }

    .btn-icon:hover {
      background: #3f3f51;
      color: #fff;
    }

    .log-container {
      background: #0f0f1a;
      border: 1px solid #27273a;
      border-radius: 10px;
      height: 500px;
      overflow-y: auto;
      padding: 16px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.8;
    }

    .log-entry {
      padding: 8px 12px;
      border-radius: 6px;
      margin-bottom: 6px;
      border-left: 3px solid transparent;
    }

    .log-success {
      background: rgba(34, 197, 94, 0.1);
      border-left-color: #22c55e;
      color: #86efac;
    }

    .log-error {
      background: rgba(239, 68, 68, 0.1);
      border-left-color: #ef4444;
      color: #fca5a5;
    }

    .log-info {
      background: rgba(59, 130, 246, 0.1);
      border-left-color: #3b82f6;
      color: #93c5fd;
    }

    .log-warning {
      background: rgba(245, 158, 11, 0.1);
      border-left-color: #f59e0b;
      color: #fcd34d;
    }

    .timestamp {
      color: #71717a;
      font-size: 11px;
      margin-right: 8px;
    }

    .log-container::-webkit-scrollbar {
      width: 8px;
    }

    .log-container::-webkit-scrollbar-track {
      background: #1c1c2e;
      border-radius: 10px;
    }

    .log-container::-webkit-scrollbar-thumb {
      background: #3f3f51;
      border-radius: 10px;
    }

    .log-container::-webkit-scrollbar-thumb:hover {
      background: #4b4b5f;
    }

    .chart-card {
      background: #1c1c2e;
      border-radius: 16px;
      padding: 24px;
      border: 1px solid #2d2d44;
    }

    .chart-header {
      margin-bottom: 20px;
    }

    .chart-header h3 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .chart-header p {
      font-size: 13px;
      color: #71717a;
    }

    .uptime-bar {
      height: 40px;
      background: #27273a;
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      margin-bottom: 12px;
    }

    .uptime-segment {
      height: 100%;
      transition: all 0.3s;
    }

    .uptime-success {
      background: #22c55e;
    }

    .uptime-error {
      background: #ef4444;
    }

    .uptime-stats {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      color: #a1a1aa;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(8px);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: #1c1c2e;
      border-radius: 16px;
      padding: 32px;
      max-width: 500px;
      width: 90%;
      border: 1px solid #2d2d44;
    }

    .modal-header {
      margin-bottom: 24px;
    }

    .modal-header h3 {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .modal-header p {
      color: #71717a;
      font-size: 14px;
    }

    .export-options {
      display: grid;
      gap: 12px;
      margin-bottom: 24px;
    }

    .export-option {
      background: #27273a;
      border: 2px solid #3f3f51;
      border-radius: 10px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .export-option:hover {
      border-color: #6366f1;
      background: #2d2d44;
    }

    .export-option-info h4 {
      font-size: 15px;
      margin-bottom: 4px;
    }

    .export-option-info p {
      font-size: 12px;
      color: #71717a;
    }

    .modal-actions {
      display: flex;
      gap: 12px;
    }

    @media (max-width: 1200px) {
      .grid {
        grid-template-columns: 1fr 1fr;
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 20px;
      }

      .grid {
        grid-template-columns: 1fr;
      }

      .form-row {
        grid-template-columns: 1fr;
      }

      .two-column {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
<div class="header">
  <h1>üöÄ Backend Pinger Pro</h1>
  <p>Enterprise-grade uptime monitoring with advanced analytics</p>
</div>

<div class="container">
  <!-- Stats Cards -->
  <div class="grid">
    <div class="card card-info">
      <div class="card-title">Total Pings</div>
      <div class="card-value" id="totalPings">0</div>
      <div class="card-subtitle">All time requests</div>
    </div>
    <div class="card card-success">
      <div class="card-title">Successful</div>
      <div class="card-value" id="successPings">0</div>
      <div class="card-subtitle" id="successRate">100% success rate</div>
    </div>
    <div class="card card-error">
      <div class="card-title">Failed</div>
      <div class="card-value" id="failedPings">0</div>
      <div class="card-subtitle" id="failedRate">0% failure rate</div>
    </div>
    <div class="card card-warning">
      <div class="card-title">Avg Response</div>
      <div class="card-value" id="avgResponse">0ms</div>
      <div class="card-subtitle">Average latency</div>
    </div>
  </div>

  <!-- Control Panel -->
  <div class="control-panel">
    <div class="form-row">
      <div class="form-group">
        <label for="url">Backend URL</label>
        <input type="url" id="url" placeholder="https://your-backend.com/health" value="https://wrytix.onrender.com/posts">
      </div>
      <div class="form-group">
        <label for="interval">Ping Interval (minutes)</label>
        <input type="number" id="interval" min="1" max="60" value="5">
      </div>
    </div>
    <div class="button-group">
      <button class="btn-primary" id="startBtn">
        <span>‚ñ∂</span> Start Monitoring
      </button>
      <button class="btn-danger" id="stopBtn" disabled>
        <span>‚è∏</span> Stop Monitoring
      </button>
      <button class="btn-secondary" id="resetBtn">
        <span>üîÑ</span> Reset Stats
      </button>
    </div>
  </div>

  <!-- Status Banner -->
  <div class="status-banner" id="statusBanner">
    <div class="status-info">
      <div class="status-dot"></div>
      <div>
        <strong id="statusText">System Idle</strong>
        <div style="font-size: 12px; color: #71717a; margin-top: 2px;">
          Last ping: <span id="lastPing">Never</span> | Next ping: <span id="nextPing">-</span>
        </div>
      </div>
    </div>
    <div style="font-size: 13px; color: #a1a1aa;">
      Uptime: <strong id="uptimePercent">0%</strong>
    </div>
  </div>

  <!-- Two Column Layout -->
  <div class="two-column">
    <!-- Logs -->
    <div class="log-panel">
      <div class="log-header">
        <h3>Activity Logs</h3>
        <div class="log-actions">
          <button class="btn-icon" id="clearLogsBtn">üóëÔ∏è Clear</button>
          <button class="btn-icon" id="exportBtn">üì• Export</button>
        </div>
      </div>
      <div class="log-container" id="logContainer">
        <div class="log-entry log-info">
          <span class="timestamp">[00:00:00]</span>
          <span>System initialized. Ready to start monitoring.</span>
        </div>
      </div>
    </div>

    <!-- Uptime Chart -->
    <div class="chart-card">
      <div class="chart-header">
        <h3>Uptime Overview</h3>
        <p>Last 24 hours performance</p>
      </div>
      <div class="uptime-bar" id="uptimeBar">
        <div class="uptime-segment uptime-success" style="width: 100%"></div>
      </div>
      <div class="uptime-stats">
        <span>‚úÖ <strong id="uptimeSuccess">0</strong> successful</span>
        <span>‚ùå <strong id="uptimeFailed">0</strong> failed</span>
      </div>
    </div>
  </div>
</div>

<!-- Export Modal -->
<div class="modal" id="exportModal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Export Logs</h3>
      <p>Select a time range to download your logs</p>
    </div>
    <div class="export-options">
      <div class="export-option" data-range="24h">
        <div class="export-option-info">
          <h4>Last 24 Hours</h4>
          <p>Export logs from the past day</p>
        </div>
        <span>üìÑ</span>
      </div>
      <div class="export-option" data-range="7d">
        <div class="export-option-info">
          <h4>Last 7 Days</h4>
          <p>Export logs from the past week</p>
        </div>
        <span>üìÑ</span>
      </div>
      <div class="export-option" data-range="14d">
        <div class="export-option-info">
          <h4>Last 2 Weeks</h4>
          <p>Export logs from the past 2 weeks</p>
        </div>
        <span>üìÑ</span>
      </div>
      <div class="export-option" data-range="30d">
        <div class="export-option-info">
          <h4>Last Month</h4>
          <p>Export logs from the past 30 days</p>
        </div>
        <span>üìÑ</span>
      </div>
      <div class="export-option" data-range="90d">
        <div class="export-option-info">
          <h4>Last 3 Months</h4>
          <p>Export logs from the past 90 days</p>
        </div>
        <span>üìÑ</span>
      </div>
      <div class="export-option" data-range="180d">
        <div class="export-option-info">
          <h4>Last 6 Months</h4>
          <p>Export logs from the past 180 days</p>
        </div>
        <span>üìÑ</span>
      </div>
      <div class="export-option" data-range="365d">
        <div class="export-option-info">
          <h4>Last Year</h4>
          <p>Export logs from the past 365 days</p>
        </div>
        <span>üìÑ</span>
      </div>
      <div class="export-option" data-range="all">
        <div class="export-option-info">
          <h4>All Time</h4>
          <p>Export all available logs</p>
        </div>
        <span>üìÑ</span>
      </div>
    </div>
    <div class="modal-actions">
      <button class="btn-secondary" style="flex: 1" id="closeModalBtn">Cancel</button>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
  // Wait for jsPDF to load
  window.addEventListener('load', function() {
    initializeApp();
  });

  function initializeApp() {
    // State management
    let intervalId = null;
    let logs = [];
    let stats = {
      total: 0,
      success: 0,
      failed: 0,
      responseTimes: []
    };

    // DOM elements
    const urlInput = document.getElementById('url');
    const intervalInput = document.getElementById('interval');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const resetBtn = document.getElementById('resetBtn');
    const statusBanner = document.getElementById('statusBanner');
    const statusText = document.getElementById('statusText');
    const lastPing = document.getElementById('lastPing');
    const nextPing = document.getElementById('nextPing');
    const totalPings = document.getElementById('totalPings');
    const successPings = document.getElementById('successPings');
    const failedPings = document.getElementById('failedPings');
    const avgResponse = document.getElementById('avgResponse');
    const successRate = document.getElementById('successRate');
    const failedRate = document.getElementById('failedRate');
    const uptimePercent = document.getElementById('uptimePercent');
    const logContainer = document.getElementById('logContainer');
    const clearLogsBtn = document.getElementById('clearLogsBtn');
    const exportBtn = document.getElementById('exportBtn');
    const exportModal = document.getElementById('exportModal');
    const closeModalBtn = document.getElementById('closeModalBtn');
    const uptimeBar = document.getElementById('uptimeBar');
    const uptimeSuccess = document.getElementById('uptimeSuccess');
    const uptimeFailed = document.getElementById('uptimeFailed');

    // Load saved data
    function loadData() {
      const savedLogs = localStorage.getItem('pingerLogs');
      const savedStats = localStorage.getItem('pingerStats');

      if (savedLogs) {
        logs = JSON.parse(savedLogs);
        renderLogs();
      }

      if (savedStats) {
        stats = JSON.parse(savedStats);
        updateUI();
      }
    }

    // Save data
    function saveData() {
      localStorage.setItem('pingerLogs', JSON.stringify(logs));
      localStorage.setItem('pingerStats', JSON.stringify(stats));
    }

    // Add log entry
    function addLog(message, type = 'info', responseTime = null) {
      const timestamp = new Date();
      const log = {
        timestamp,
        message,
        type,
        responseTime
      };

      logs.unshift(log);

      // Keep only last 1000 logs in memory
      if (logs.length > 1000) {
        logs = logs.slice(0, 1000);
      }

      saveData();
      renderLogs();
    }

    // Render logs
    function renderLogs() {
      logContainer.innerHTML = logs.map(log => {
        const time = log.timestamp.toLocaleTimeString();
        const responseInfo = log.responseTime ? ` (${log.responseTime}ms)` : '';
        return `
          <div class="log-entry log-${log.type}">
            <span class="timestamp">[${time}]</span>
            <span>${log.message}${responseInfo}</span>
          </div>
        `;
      }).join('');
    }

    // Update UI
    function updateUI() {
      totalPings.textContent = stats.total;
      successPings.textContent = stats.success;
      failedPings.textContent = stats.failed;

      const successRateVal = stats.total > 0 ? ((stats.success / stats.total) * 100).toFixed(1) : 100;
      const failedRateVal = stats.total > 0 ? ((stats.failed / stats.total) * 100).toFixed(1) : 0;

      successRate.textContent = `${successRateVal}% success rate`;
      failedRate.textContent = `${failedRateVal}% failure rate`;
      uptimePercent.textContent = `${successRateVal}%`;

      const avgResp = stats.responseTimes.length > 0
        ? Math.round(stats.responseTimes.reduce((a, b) => a + b, 0) / stats.responseTimes.length)
        : 0;
      avgResponse.textContent = `${avgResp}ms`;

      // Update uptime bar
      if (stats.total > 0) {
        const successWidth = (stats.success / stats.total) * 100;
        uptimeBar.innerHTML = `
          <div class="uptime-segment uptime-success" style="width: ${successWidth}%"></div>
          <div class="uptime-segment uptime-error" style="width: ${100 - successWidth}%"></div>
        `;
      }

      uptimeSuccess.textContent = stats.success;
      uptimeFailed.textContent = stats.failed;
    }

    // Update next ping time
    function updateNextPing() {
      const minutes = parseInt(intervalInput.value);
      const nextTime = new Date(Date.now() + minutes * 60000);
      nextPing.textContent = nextTime.toLocaleTimeString();
    }

    // Ping backend
    async function pingBackend() {
      const url = urlInput.value.trim();

      if (!url) {
        addLog('No URL provided', 'error');
        return;
      }

      stats.total++;

      try {
        addLog(`Pinging ${url}...`, 'info');
        const startTime = Date.now();

        const response = await fetch(url, {
          method: 'GET',
          mode: 'no-cors'
        });

        const responseTime = Date.now() - startTime;
        stats.responseTimes.push(responseTime);

        // Keep only last 100 response times
        if (stats.responseTimes.length > 100) {
          stats.responseTimes = stats.responseTimes.slice(-100);
        }

        stats.success++;
        addLog(`Ping successful`, 'success', responseTime);

      } catch (error) {
        stats.failed++;
        addLog(`Ping failed: ${error.message}`, 'error');
      }

      lastPing.textContent = new Date().toLocaleTimeString();
      updateUI();
      updateNextPing();
      saveData();
    }

    // Start monitoring
    startBtn.addEventListener('click', () => {
      const url = urlInput.value.trim();

      if (!url) {
        alert('Please enter a valid URL');
        return;
      }

      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        alert('URL must start with http:// or https://');
        return;
      }

      const minutes = parseInt(intervalInput.value);

      if (minutes < 1 || minutes > 60) {
        alert('Interval must be between 1 and 60 minutes');
        return;
      }

      // Ping immediately
      pingBackend();

      // Set up interval
      intervalId = setInterval(pingBackend, minutes * 60000);

      // Update UI
      startBtn.disabled = true;
      stopBtn.disabled = false;
      urlInput.disabled = true;
      intervalInput.disabled = true;
      statusBanner.classList.add('active');
      statusText.textContent = `Monitoring Active (${minutes}min intervals)`;

      addLog(`Monitoring started - Pinging every ${minutes} minute(s)`, 'success');
      updateNextPing();
    });

    // Stop monitoring
    stopBtn.addEventListener('click', () => {
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }

      startBtn.disabled = false;
      stopBtn.disabled = true;
      urlInput.disabled = false;
      intervalInput.disabled = false;
      statusBanner.classList.remove('active');
      statusText.textContent = 'System Idle';
      nextPing.textContent = '-';

      addLog('Monitoring stopped', 'warning');
    });

    // Reset stats
    resetBtn.addEventListener('click', () => {
      if (confirm('Are you sure you want to reset all statistics? This action cannot be undone.')) {
        stats = {
          total: 0,
          success: 0,
          failed: 0,
          responseTimes: []
        };
        logs = [];
        saveData();
        updateUI();
        renderLogs();
        addLog('Statistics reset', 'info');
      }
    });

    // Clear logs
    clearLogsBtn.addEventListener('click', () => {
      if (confirm('Clear all logs? This action cannot be undone.')) {
        logs = [];
        saveData();
        renderLogs();
        addLog('Logs cleared', 'info');
      }
    });

    // Export modal
    exportBtn.addEventListener('click', () => {
      exportModal.classList.add('active');
    });

    closeModalBtn.addEventListener('click', () => {
      exportModal.classList.remove('active');
    });

    exportModal.addEventListener('click', (e) => {
      if (e.target === exportModal) {
        exportModal.classList.remove('active');
      }
    });

    // Export functionality
    document.querySelectorAll('.export-option').forEach(option => {
      option.addEventListener('click', () => {
        const range = option.dataset.range;
        exportLogs(range);
        exportModal.classList.remove('active');
      });
    });

    function exportLogs(range) {
      const now = Date.now();
      let filteredLogs = logs;
      let rangeLabel = 'All Time';

      // Filter logs based on range
      const ranges = {
        '24h': { ms: 24 * 60 * 60 * 1000, label: 'Last 24 Hours' },
        '7d': { ms: 7 * 24 * 60 * 60 * 1000, label: 'Last 7 Days' },
        '14d': { ms: 14 * 24 * 60 * 60 * 1000, label: 'Last 2 Weeks' },
        '30d': { ms: 30 * 24 * 60 * 60 * 1000, label: 'Last Month' },
        '90d': { ms: 90 * 24 * 60 * 60 * 1000, label: 'Last 3 Months' },
        '180d': { ms: 180 * 24 * 60 * 60 * 1000, label: 'Last 6 Months' },
        '365d': { ms: 365 * 24 * 60 * 60 * 1000, label: 'Last Year' }
      };

      if (range !== 'all' && ranges[range]) {
        const cutoff = now - ranges[range].ms;
        filteredLogs = logs.filter(log => new Date(log.timestamp).getTime() >= cutoff);
        rangeLabel = ranges[range].label;
      }

      if (filteredLogs.length === 0) {
        alert('No logs found for this time range.');
        return;
      }

      // Calculate statistics for filtered logs
      const exportStats = {
        total: filteredLogs.length,
        success: filteredLogs.filter(l => l.type === 'success').length,
        failed: filteredLogs.filter(l => l.type === 'error').length,
        info: filteredLogs.filter(l => l.type === 'info').length,
        warning: filteredLogs.filter(l => l.type === 'warning').length
      };

      const responseTimes = filteredLogs
        .filter(l => l.responseTime)
        .map(l => l.responseTime);

      const avgResponseTime = responseTimes.length > 0
        ? Math.round(responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length)
        : 0;

      const successRate = exportStats.total > 0
        ? ((exportStats.success / exportStats.total) * 100).toFixed(2)
        : 0;

      // Create PDF
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();

      let yPos = 20;
      const pageHeight = doc.internal.pageSize.height;
      const margin = 20;
      const lineHeight = 7;

      // Helper function to check if we need a new page
      function checkPageBreak() {
        if (yPos > pageHeight - 30) {
          doc.addPage();
          yPos = 20;
        }
      }

      // Title
      doc.setFontSize(20);
      doc.setTextColor(30, 58, 138);
      doc.text('Backend Pinger Pro', margin, yPos);
      yPos += 10;

      doc.setFontSize(12);
      doc.setTextColor(100, 100, 100);
      doc.text('Uptime Monitoring Report', margin, yPos);
      yPos += 15;

      // Header info
      doc.setFontSize(10);
      doc.setTextColor(60, 60, 60);
      doc.text(`Export Date: ${new Date().toLocaleString()}`, margin, yPos);
      yPos += lineHeight;
      doc.text(`Time Range: ${rangeLabel}`, margin, yPos);
      yPos += lineHeight;
      doc.text(`Backend URL: ${urlInput.value}`, margin, yPos);
      yPos += 12;

      // Statistics Section
      doc.setFontSize(14);
      doc.setTextColor(30, 58, 138);
      doc.text('Summary Statistics', margin, yPos);
      yPos += 10;

      // Draw statistics box
      doc.setFillColor(248, 250, 252);
      doc.rect(margin, yPos - 5, 170, 50, 'F');

      doc.setFontSize(10);
      doc.setTextColor(60, 60, 60);

      const statsY = yPos;
      doc.text(`Total Pings: ${exportStats.total}`, margin + 5, statsY);
      yPos += lineHeight;
      doc.text(`Successful: ${exportStats.success} (${successRate}%)`, margin + 5, yPos);
      yPos += lineHeight;
      doc.text(`Failed: ${exportStats.failed}`, margin + 5, yPos);
      yPos += lineHeight;
      doc.text(`Info Messages: ${exportStats.info}`, margin + 5, yPos);
      yPos += lineHeight;
      doc.text(`Warnings: ${exportStats.warning}`, margin + 5, yPos);
      yPos += lineHeight;
      doc.text(`Average Response Time: ${avgResponseTime}ms`, margin + 5, yPos);
      yPos += 15;

      checkPageBreak();

      // Detailed Logs Section
      doc.setFontSize(14);
      doc.setTextColor(30, 58, 138);
      doc.text('Detailed Logs', margin, yPos);
      yPos += 10;

      doc.setFontSize(8);
      doc.setTextColor(60, 60, 60);

      // Add logs with color coding
      filteredLogs.forEach((log, index) => {
        checkPageBreak();

        const timestamp = new Date(log.timestamp).toLocaleString();
        const responseInfo = log.responseTime ? ` [${log.responseTime}ms]` : '';

        // Set color based on log type
        switch(log.type) {
          case 'success':
            doc.setTextColor(34, 197, 94);
            break;
          case 'error':
            doc.setTextColor(239, 68, 68);
            break;
          case 'warning':
            doc.setTextColor(245, 158, 11);
            break;
          default:
            doc.setTextColor(59, 130, 246);
        }

        // Draw log entry with background
        if (index % 2 === 0) {
          doc.setFillColor(250, 250, 250);
          doc.rect(margin, yPos - 4, 170, lineHeight, 'F');
        }

        const logText = `${timestamp} | ${log.type.toUpperCase()} | ${log.message}${responseInfo}`;
        const splitText = doc.splitTextToSize(logText, 170);

        splitText.forEach(line => {
          checkPageBreak();
          doc.text(line, margin + 2, yPos);
          yPos += lineHeight;
        });
      });

      // Footer on last page
      const totalPages = doc.internal.pages.length - 1;
      for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor(150, 150, 150);
        doc.text(
          `Page ${i} of ${totalPages} | Generated by Backend Pinger Pro`,
          margin,
          pageHeight - 10
        );
      }

      // Save PDF
      doc.save(`pinger-report-${range}-${Date.now()}.pdf`);

      addLog(`PDF report exported: ${rangeLabel} (${filteredLogs.length} entries)`, 'info');
    }

    // Load saved data
    function loadData() {
      const savedLogs = localStorage.getItem('pingerLogs');
      const savedStats = localStorage.getItem('pingerStats');

      if (savedLogs) {
        logs = JSON.parse(savedLogs);
        renderLogs();
      }

      if (savedStats) {
        stats = JSON.parse(savedStats);
        updateUI();
      }
    }

    // Save data
    function saveData() {
      localStorage.setItem('pingerLogs', JSON.stringify(logs));
      localStorage.setItem('pingerStats', JSON.stringify(stats));
    }

    // Add log entry
    function addLog(message, type = 'info', responseTime = null) {
      const timestamp = new Date();
      const log = {
        timestamp,
        message,
        type,
        responseTime
      };

      logs.unshift(log);

      // Keep only last 1000 logs in memory
      if (logs.length > 1000) {
        logs = logs.slice(0, 1000);
      }

      saveData();
      renderLogs();
    }

    // Render logs
    function renderLogs() {
      logContainer.innerHTML = logs.map(log => {
        const time = new Date(log.timestamp).toLocaleTimeString();
        const responseInfo = log.responseTime ? ` (${log.responseTime}ms)` : '';
        return `
            <div class="log-entry log-${log.type}">
              <span class="timestamp">[${time}]</span>
              <span>${log.message}${responseInfo}</span>
            </div>
          `;
      }).join('');
    }

    // Update UI
    function updateUI() {
      totalPings.textContent = stats.total;
      successPings.textContent = stats.success;
      failedPings.textContent = stats.failed;

      const successRateVal = stats.total > 0 ? ((stats.success / stats.total) * 100).toFixed(1) : 100;
      const failedRateVal = stats.total > 0 ? ((stats.failed / stats.total) * 100).toFixed(1) : 0;

      successRate.textContent = `${successRateVal}% success rate`;
      failedRate.textContent = `${failedRateVal}% failure rate`;
      uptimePercent.textContent = `${successRateVal}%`;

      const avgResp = stats.responseTimes.length > 0
        ? Math.round(stats.responseTimes.reduce((a, b) => a + b, 0) / stats.responseTimes.length)
        : 0;
      avgResponse.textContent = `${avgResp}ms`;

      // Update uptime bar
      if (stats.total > 0) {
        const successWidth = (stats.success / stats.total) * 100;
        uptimeBar.innerHTML = `
            <div class="uptime-segment uptime-success" style="width: ${successWidth}%"></div>
            <div class="uptime-segment uptime-error" style="width: ${100 - successWidth}%"></div>
          `;
      }

      uptimeSuccess.textContent = stats.success;
      uptimeFailed.textContent = stats.failed;
    }

    // Update next ping time
    function updateNextPing() {
      const minutes = parseInt(intervalInput.value);
      const nextTime = new Date(Date.now() + minutes * 60000);
      nextPing.textContent = nextTime.toLocaleTimeString();
    }

    // Ping backend
    async function pingBackend() {
      const url = urlInput.value.trim();

      if (!url) {
        addLog('No URL provided', 'error');
        return;
      }

      stats.total++;

      try {
        addLog(`Pinging ${url}...`, 'info');
        const startTime = Date.now();

        const response = await fetch(url, {
          method: 'GET',
          mode: 'no-cors'
        });

        const responseTime = Date.now() - startTime;
        stats.responseTimes.push(responseTime);

        // Keep only last 100 response times
        if (stats.responseTimes.length > 100) {
          stats.responseTimes = stats.responseTimes.slice(-100);
        }

        stats.success++;
        addLog(`Ping successful`, 'success', responseTime);

      } catch (error) {
        stats.failed++;
        addLog(`Ping failed: ${error.message}`, 'error');
      }

      lastPing.textContent = new Date().toLocaleTimeString();
      updateUI();
      updateNextPing();
      saveData();
    }

    // Start monitoring
    startBtn.addEventListener('click', () => {
      const url = urlInput.value.trim();

      if (!url) {
        alert('Please enter a valid URL');
        return;
      }

      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        alert('URL must start with http:// or https://');
        return;
      }

      const minutes = parseInt(intervalInput.value);

      if (minutes < 1 || minutes > 60) {
        alert('Interval must be between 1 and 60 minutes');
        return;
      }

      // Ping immediately
      pingBackend();

      // Set up interval
      intervalId = setInterval(pingBackend, minutes * 60000);

      // Update UI
      startBtn.disabled = true;
      stopBtn.disabled = false;
      urlInput.disabled = true;
      intervalInput.disabled = true;
      statusBanner.classList.add('active');
      statusText.textContent = `Monitoring Active (${minutes}min intervals)`;

      addLog(`Monitoring started - Pinging every ${minutes} minute(s)`, 'success');
      updateNextPing();
    });

    // Stop monitoring
    stopBtn.addEventListener('click', () => {
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }

      startBtn.disabled = false;
      stopBtn.disabled = true;
      urlInput.disabled = false;
      intervalInput.disabled = false;
      statusBanner.classList.remove('active');
      statusText.textContent = 'System Idle';
      nextPing.textContent = '-';

      addLog('Monitoring stopped', 'warning');
    });

    // Reset stats
    resetBtn.addEventListener('click', () => {
      if (confirm('Are you sure you want to reset all statistics? This action cannot be undone.')) {
        stats = {
          total: 0,
          success: 0,
          failed: 0,
          responseTimes: []
        };
        logs = [];
        saveData();
        updateUI();
        renderLogs();
        addLog('Statistics reset', 'info');
      }
    });

    // Clear logs
    clearLogsBtn.addEventListener('click', () => {
      if (confirm('Clear all logs? This action cannot be undone.')) {
        logs = [];
        saveData();
        renderLogs();
        addLog('Logs cleared', 'info');
      }
    });

    // Export modal
    exportBtn.addEventListener('click', () => {
      exportModal.classList.add('active');
    });

    closeModalBtn.addEventListener('click', () => {
      exportModal.classList.remove('active');
    });

    exportModal.addEventListener('click', (e) => {
      if (e.target === exportModal) {
        exportModal.classList.remove('active');
      }
    });

    // Export functionality
    document.querySelectorAll('.export-option').forEach(option => {
      option.addEventListener('click', () => {
        const range = option.dataset.range;
        exportLogs(range);
        exportModal.classList.remove('active');
      });
    });

    function exportLogs(range) {
      const now = Date.now();
      let filteredLogs = logs;
      let rangeLabel = 'All Time';

      // Filter logs based on range
      const ranges = {
        '24h': { ms: 24 * 60 * 60 * 1000, label: 'Last 24 Hours' },
        '7d': { ms: 7 * 24 * 60 * 60 * 1000, label: 'Last 7 Days' },
        '14d': { ms: 14 * 24 * 60 * 60 * 1000, label: 'Last 2 Weeks' },
        '30d': { ms: 30 * 24 * 60 * 60 * 1000, label: 'Last Month' },
        '90d': { ms: 90 * 24 * 60 * 60 * 1000, label: 'Last 3 Months' },
        '180d': { ms: 180 * 24 * 60 * 60 * 1000, label: 'Last 6 Months' },
        '365d': { ms: 365 * 24 * 60 * 60 * 1000, label: 'Last Year' }
      };

      if (range !== 'all' && ranges[range]) {
        const cutoff = now - ranges[range].ms;
        filteredLogs = logs.filter(log => new Date(log.timestamp).getTime() >= cutoff);
        rangeLabel = ranges[range].label;
      }

      if (filteredLogs.length === 0) {
        alert('No logs found for this time range.');
        return;
      }


      // Calculate statistics for filtered logs
      const exportStats = {
        total: filteredLogs.length,
        success: filteredLogs.filter(l => l.type === 'success').length,
        failed: filteredLogs.filter(l => l.type === 'error').length,
        info: filteredLogs.filter(l => l.type === 'info').length,
        warning: filteredLogs.filter(l => l.type === 'warning').length
      };

      const responseTimes = filteredLogs
        .filter(l => l.responseTime)
        .map(l => l.responseTime);

      const avgResponseTime = responseTimes.length > 0
        ? Math.round(responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length)
        : 0;

      const successRate = exportStats.total > 0
        ? ((exportStats.success / exportStats.total) * 100).toFixed(2)
        : 0;

      // Create PDF
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();

      let yPos = 20;
      const pageHeight = doc.internal.pageSize.height;
      const margin = 20;
      const lineHeight = 7;

      // Helper function to check if we need a new page
      function checkPageBreak() {
        if (yPos > pageHeight - 30) {
          doc.addPage();
          yPos = 20;
        }
      }

      // Title
      doc.setFontSize(20);
      doc.setTextColor(30, 58, 138);
      doc.text('Backend Pinger Pro', margin, yPos);
      yPos += 10;

      doc.setFontSize(12);
      doc.setTextColor(100, 100, 100);
      doc.text('Uptime Monitoring Report', margin, yPos);
      yPos += 15;

      // Header info
      doc.setFontSize(10);
      doc.setTextColor(60, 60, 60);
      doc.text(`Export Date: ${new Date().toLocaleString()}`, margin, yPos);
      yPos += lineHeight;
      doc.text(`Time Range: ${rangeLabel}`, margin, yPos);
      yPos += lineHeight;
      doc.text(`Backend URL: ${urlInput.value}`, margin, yPos);
      yPos += 12;

      // Statistics Section
      doc.setFontSize(14);
      doc.setTextColor(30, 58, 138);
      doc.text('Summary Statistics', margin, yPos);
      yPos += 10;

      // Draw statistics box
      doc.setFillColor(248, 250, 252);
      doc.rect(margin, yPos - 5, 170, 50, 'F');

      doc.setFontSize(10);
      doc.setTextColor(60, 60, 60);

      const statsY = yPos;
      doc.text(`Total Pings: ${exportStats.total}`, margin + 5, statsY);
      yPos += lineHeight;
      doc.text(`Successful: ${exportStats.success} (${successRate}%)`, margin + 5, yPos);
      yPos += lineHeight;
      doc.text(`Failed: ${exportStats.failed}`, margin + 5, yPos);
      yPos += lineHeight;
      doc.text(`Info Messages: ${exportStats.info}`, margin + 5, yPos);
      yPos += lineHeight;
      doc.text(`Warnings: ${exportStats.warning}`, margin + 5, yPos);
      yPos += lineHeight;
      doc.text(`Average Response Time: ${avgResponseTime}ms`, margin + 5, yPos);
      yPos += 15;

      checkPageBreak();

      // Detailed Logs Section
      doc.setFontSize(14);
      doc.setTextColor(30, 58, 138);
      doc.text('Detailed Logs', margin, yPos);
      yPos += 10;

      doc.setFontSize(8);
      doc.setTextColor(60, 60, 60);

      // Add logs with color coding
      filteredLogs.forEach((log, index) => {
        checkPageBreak();

        const timestamp = new Date(log.timestamp).toLocaleString();
        const responseInfo = log.responseTime ? ` [${log.responseTime}ms]` : '';

        // Set color based on log type
        switch(log.type) {
          case 'success':
            doc.setTextColor(34, 197, 94);
            break;
          case 'error':
            doc.setTextColor(239, 68, 68);
            break;
          case 'warning':
            doc.setTextColor(245, 158, 11);
            break;
          default:
            doc.setTextColor(59, 130, 246);
        }

        // Draw log entry with background
        if (index % 2 === 0) {
          doc.setFillColor(250, 250, 250);
          doc.rect(margin, yPos - 4, 170, lineHeight, 'F');
        }

        const logText = `${timestamp} | ${log.type.toUpperCase()} | ${log.message}${responseInfo}`;
        const splitText = doc.splitTextToSize(logText, 170);

        splitText.forEach(line => {
          checkPageBreak();
          doc.text(line, margin + 2, yPos);
          yPos += lineHeight;
        });
      });

      // Footer on last page
      const totalPages = doc.internal.pages.length - 1;
      for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor(150, 150, 150);
        doc.text(
          `Page ${i} of ${totalPages} | Generated by Backend Pinger Pro`,
          margin,
          pageHeight - 10
        );
      }

      // Save PDF
      doc.save(`pinger-report-${range}-${Date.now()}.pdf`);

      addLog(`PDF report exported: ${rangeLabel} (${filteredLogs.length} entries)`, 'info');
    }

    // Initialize
    loadData();

    // Auto-save periodically
    setInterval(saveData, 30000); // Save every 30 seconds
  }
</script>
</body>
</html>
